## Intel SGX学习

#### 概述

> [!NOTE]
>
> 参考文献：
>
> https://zhuanlan.zhihu.com/p/39976702
>
> https://blog.csdn.net/SGchi/article/details/136227030
>
> Intel(R) Software Guard Extensions Developer Guide

Intel SGX（全称Intel Software Guard Extensions）是Intel架构的扩展，旨在为在所有特权软件（kernel、管理程序等）都可能是潜在恶意的计算机上的安全计算提供完整性和机密性保证。它通过分配由硬件保护的内存来运行，其中包含代码和数据。受保护的内存区域称为enclave。enclave内存中的数据只能由也驻留在enclave内存空间中的代码访问。Enclave代码可以通过特殊指令调用。在Linux* OS上，可以构建和加载enclave作为**共享对象**。

Intel®Software Guard Extensions技术对受保护的内存大小有硬性限制，通常为64 MB或128 MB。根据每个enclave的内存占用，用例建议5-20个enclave可以同时驻留在内存中。不过Linux*可以通过分页来增加受保护的内存大小。

SGX的核心概念是enclave，它是一个受保护的环境，包含与安全敏感计算相关的代码和数据。支持SGX的处理器提供可信计算，通过将eclave环境和enclabve外的来自不可信软件的环境隔离开来以及实现允许远程方对enclave内运行的软件进行身份验证的软件认证方案。SGX的隔离机制旨在保护在一个enclave内执行的计算的机密性和完整性，使其免受来自同一台计算机上执行的恶意软件的攻击以及物理攻击。

SGX留出一个内存区域 **PRM**(Processor Reserved Memory)，CPU保护PRM不受所有非enclave内存访问，无论是特权级别还是CPU模式（ring3/用户模式、ring0/内核模式、SMM、VMM或其他enclave），包括kernel、管理程序和SMM、DMA。PRM外的区域为不受保护内存。PRM中包含 **EPC**（Enclave Page Cache），EPC中包含4KB的pages用来存储enclave代码和数据。每个EPC page只属于一个enclave。

enclave首先有个初始化的阶段，该部分代码和数据由不受信任的系统软件加载，待enclave加载完毕后失效。enclave初始化后，它的内容由CPU加密hash，成为该enclave的**measurement hash**。远程方可以通过measurement hash来确认enclave身份，保证它在一个安全环境下运行。

在enclave文件中，有一个特定的数据结构称为enclave metadata，metadata不加载入EPC，metadata包含enclave signature，这是enclave真实性和来源的重要证书。

#### ECALL和OCALL概念

**ECALL函数**：Enclave Call/Enclave Interface Functions，untrusted application对enclave内接口函数的调用，在EDL文件中的trusted节声明

**OCALL函数**：Outside call/Calls outside the Enclave，从enclave调用不受信任函数的函数调用。从enclave内部向外部应用程序发出的调用（如系统调用、I/O操作等），OCALL函数在EDL文件中的untrusted节中声明。enclave不能直接访问OS提供的服务，必须调用OCall

![image-20240823154606763](C:\Users\21874\AppData\Roaming\Typora\typora-user-images\image-20240823154606763.png)

##### ECall inputs & OCall outputs

不受信任的代码可以获取和修改enclave inputs和outputs，因此enclave writer必须永远不相信从不受信任域来的任何信息，必须用于检查ECall输入参数和OCall返回值



#### 设计SGX程序

英特尔®Software Guard Extensions应用程序设计不同于非英特尔®SGX应用程序，因为它需要将应用程序划分为两个逻辑组件: 

- 受信任组件：称为enclave，一个application中可以存在多个enclave，应尽可能小，建议将enclave功能限制在对秘密数据的操作上、减少OCall调用
- 不受信任组件：剩余的部分

设计SGX程序的第一步是确定它要保护的资产（assets）、assets包含的数据结构、操作在这些数据结构上的代码，然后再把它们存放在一个独立可信库中。

人们普遍认为，较小的内存占用(较小的代码和数据)通常意味着在最终软件产品中出现缺陷的可能性较低。它还意味着更简单的安全分析和更安全的软件，因为可以暴露更小的攻击面。因此TCB（Enclave Trusted Computing Base）大小需要权衡。

在定义好SGX程序的trusted（enclave）和untrusted（application）部分后，开发者应该仔细定义在untrusted application和enclave之间的interface。

#### Enclave Signature

SGX使用强大的行业标准算法来签名enclave，如果enclave的签名不正确，则无法初始化；如果enclave初始化后，它应该与初始enclave相同，并且不会在运行时被修改。

建立信任有3个主要活动：

- **Measurement**：enclave在可信环境中实例化时，将对其identity进行准确且受保护的记录

- Attestation(认证)：证明真实性。向其他实体证明以正确的方式实例化了特定的环境。在平台认证的情况下，证明平台的身份。

- 密封：允许将属于可信环境的数据绑定到可信环境，以便只有在可信环境恢复时才能恢复这些数据

  enclave包含该enclave所有者的自签名证书，也称为enclvae signature，enclave签名是的SGX能够检测它是否被篡改。签名包含的字段：

  1. Enclave Measurement ：256-bit hash，标识enclave中的代码和初始数据
  2. Enclave author的公钥：enclave成功初始化后，CPU记录公钥的hash，作为author的身份
  3. Enclave的安全版本号
  4. Enclave的产品ID

  一个enclave开发者必须提供enclave的安全版本和产品ID，以及一对**签名密钥**用来生成enclave签名。CPU从公钥派生author的身份，私钥用来给enclave签名

##### 保护Enclave签名密钥

- 保持对私有签名密钥的最小访问
- 使用其他enclave或HSM (Hardware Security Module)存放私钥并执行enclave签名
- 使用单独的密钥对将测试签名(test signing)与发布签名(release signing)分开

SDK包含一个用于对enclave进行签名的工具，称为**sgx_sign**

##### Attestation（认证）

在SGX中这是一个机制，通过该机制，第三方可以在向该软件提供机密和受保护的数据之前，确定该软件运行支持SGX的平台，受enclave保护。认证依赖于平台生成准确反映enclave签名的凭证的能力，其中包括有关enclave安全属性的信息。

SGX的两种认证机制：

1. 本地认证/平台内认证（可以是同一个application的两个enclave进行认证）
2. 远程认证/平台间认证

## Intel SGX开发

#### Intel SGX开发初学整体思路

（1）首先在**App.cpp**中编写自己的需求，这里是应用程序区，也可以说是**不可信区**；
（2）App.cpp中需要Enclave进行安全计算的，在Enclave.edl中定义相应的函数接口，对特定形参要明确 in 和 out ；
（3）在Enclave.cpp中实现定义的接口，在安全区中进行具体编码操作；
（4）在Enclave.h进行一些头文件的函数声明。

遵循最小特权原则

#### 如何在自己的工作区使用SGX

将SGX项目从官方示例项目[文件复制](https://so.csdn.net/so/search?q=文件复制&spm=1001.2101.3001.7020)到自己的工作目录

1、将SGX实例项目复制到你自己的工作目录
sudo cp -r /opt/intel/sgxsdk/SampleCode/SampleEnclave ~/vsCodeProjects/(这里是你的工作目录路径)
2、进入到你已经复制好的工作目录的SGX项目
cd /vsCodeProjects/SampleEnclave
3、修改权限从超级用户修改为普通用户
sudo chown -R master:master .（chown 命令将文件夹的所有权更改为 master 用户，也就是你自己的用户名）

**注意：每次编译！！！每次编译！！！每次编译！！！之前都要source一下**

```linux
source /opt/intel/sgxsdk/environment
```

#### SGX项目目录结构

[SGX项目目录结构]: https://blog.csdn.net/m0_47575110/article/details/135555087?spm=1001.2014.3001.5502

以SampleEnclave项目为例，这个项目是一个最[初始化](https://so.csdn.net/so/search?q=初始化&spm=1001.2101.3001.7020)的SGX项目

![image-20240822203704393](C:\Users\21874\AppData\Roaming\Typora\typora-user-images\image-20240822203704393.png)

App文件夹：编写程序的地方，不可信区

enclave文件夹：安全区enclave代码编写实现和ECALL、OCALL函数的实现

EDL（Enclave Definition Language）

在Intel SGX项目中，通常应该准备以下文件:

- Enclave定义语言(EDL)文件-描述在函数原型中使用的Enclave可信和不可信函数和类型。
- Enclave Configuration File (ECF)——包含Enclave元数据的信息
- 签名密钥文件——用于对enclave进行签名，以生成包含enclave属性(如enclave measurement)的签名结构
- 应用程序和enclave源代码-应用程序和enclave函数的实现
- makefile
- Linker script file(Enclave.lds)

编译前的项目结构：

```plaintext
HelloWorld/
├── App
│   ├── App.cpp
│   └── App.h
├── Enclave
│   ├── Enclave.config.xml
│   ├── Enclave.cpp  #应用安全区代码实现
│   ├── Enclave.edl
│   ├── Enclave.h    #应用安全区代码实现
│   ├── Enclave.lds  #Enclave linker script
│   └── Enclave_private.pem #enclave.so 的签名私钥
├── Include
└── Makefile
```

编译后的项目结构：

```plaintext
HelloWorld
├── app #[generated]
├── App
│   ├── App.cpp
│   ├── App.h
│   ├── App.o        #[generated]
│   ├── Enclave_u.c  #[generated] 即Enclave_untrusted.c
│   ├── Enclave_u.h  #[generated] 
│   └── Enclave_u.o  #[generated]
├── Enclave
│   ├── Enclave.config.xml
│   ├── Enclave.cpp
│   ├── Enclave.edl
│   ├── Enclave.h
│   ├── Enclave.lds
│   ├── Enclave.o     #[generated]
│   ├── Enclave_private.pem
│   ├── Enclave_t.c   #[generated] 即Enclave_trusted.c
│   ├── Enclave_t.h   #[generated]
│   └── Enclave_t.o   #[generated]
├── enclave.signed.so #[generated] 通过sgx_sig工具签名可信动态链接库
├── enclave.so        #[generated] 可信动态链接库
├── Include
└── Makefile
```

**编译基本流程(Makefile):**

1. 通过 `sgx_edger8r` 工具在 `App/` 目录下生成不可信代码(Enclave_u.c 和 Enclave_u.h)，这部分生成代码主要会调用 ECALL (sgx_ecall)；
2. 编译不可信部分 Binary: `app`；
3. 通过`sgx_edger8r` 工具在 `Enclave/` 目录下生成可信代码(Enclave_t.c 和 Enclave_t.h)；
4. 编译可信动态链接库(enclave.so)；
5. 通过`sgx_sign`工具签名可信动态链接库(enclave.signed.so)；
6. 结束。

#### SGX提供的tool

在/opt/intel/sgxsdk/bin/x64中

- SGX_EDGER8R
- sgx_sign：给enclave签名是一个产生包含enclave属性（如enclave measurement)的签名结构的签名结构的过程。sgx_sign通常由Intel®SGX SDK中包含的配置工具之一设置，并在构建过程结束时自动运行。
  - 单步签名：使用 ISV 的 test private key，由该key签名的enclave只能在debug和prerelease模式下启动。ISV管理签名密钥对，该密钥对可以由ISV使用自己的方式生成。单步方法是非生产enclave应用程序的默认签名方法
  - 2-step 方法：使用外部签名工具。是SGX项目release的默认签名方法，是生产模式的唯一方法

<img src="C:\Users\21874\AppData\Roaming\Typora\typora-user-images\image-20240826145658824.png" alt="image-20240826145658824" style="zoom:50%;" />

##### openssl

```
openssl genrsa -out private_key.pem -3 3072
openssl rsa -in private_key.pem -pubout -out public_key.pem
openssl dgst -sha256 -out signature.dat -sign private_key.pem -keyform PEM enclave_sig.dat
```

#### enclave开发过程

- 在EDL文件中定义不受信任的应用程序和enclave之间的接口
- 实现应用程序和enclave功能
- 构建应用程序和enclave。在构建过程中，Edger8r Tool生成可信和不可信的代理/桥接函数。Enclave签名工具为Enclave生成元数据和签名
- 在仿真和硬件模式下运行和调试应用程序
- 准备发布应用程序和enclave

#### ECALL编写（p29）

当一个enclave加载成功后，获得一个enclave ID，作为ECALL的参数，OCALL也可以在ECALL中被调用

#### OCALL编写

存在一些情况，enclave中的代码需要调用不可信内存中的外部方法来使用enclave外的操作系统能力，如系统调用、I/O操作等，这种方法调用就叫OCALL，这些方法在EDL文件中的untrusted部分声明

#### Linking Enclave with Libraries

enclave共享对象不能以任何方式依赖于任何动态链接库。如果enclave文件有任何未解析的依赖项，则enclave镜像签名过程将失败。

只要静态库没有任何依赖关系，就可以链接它们。

#### EDL语法

- 头文件：全局包含的头文件并不意味着在enclave和不受信任的应用程序代码中包含相同的头文件。比如同样是stdio.h，enclave将使用来自Intel®Software Guard Extensions SDK的stdio .h，而应用程序代码将使用主机编译器附带的stdio.h。当开发人员将现有代码迁移到Intel SGX技术时，使用include指令非常方便，因为在这种情况下已经定义了数据类型。

  <img src="C:\Users\21874\AppData\Roaming\Typora\typora-user-images\image-20240828225005765.png" alt="image-20240828225005765" style="zoom: 67%;" />

- in/out

  <img src="C:\Users\21874\AppData\Roaming\Typora\typora-user-images\image-20240828230350532.png" alt="image-20240828230350532" style="zoom:67%;" />

  <img src="C:\Users\21874\AppData\Roaming\Typora\typora-user-images\image-20240828230410777.png" alt="image-20240828230410777" style="zoom:67%;" />

### 库函数和类型引用

#### 不可信库函数

不可信库函数只能被app调用，即在enclave之外。













