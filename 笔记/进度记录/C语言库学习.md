## 库文件和头文件

### 库文件

我们可以将库文件等价为压缩包文件，该文件内部通常包含不止一个目标文件（也就是二进制文件）。值得一提的是，库文件中每个目标文件存储的代码，并非完整的程序，而是一个个实用的功能模块。例如，C 语言库文件提供有大量的函数（如 printf()、memset()、strlen() 等），C++ 库文件不仅提供有使用的函数，还有大量事先设计好的类（如 string 字符串类）。

库文件的产生，极大的提高了程序员的开发效率，因为很多功能都是现成并且很成熟，使用者根本不需要重新造轮子，直接调取包含该功能的库文件即可。并且，库文件的调用方法也很简单，以 C 语言中的 printf() 输出函数为例，程序中只需引入 <stdio.h> 头文件，即可调用 printf() 函数。

### 库文件和头文件的区别

库文件我们看不到里面的内容，头文件我们确可以实实在在的看到。那么调用库文件为什么还要牵扯到头文件呢？首先，头文件和库文件并不是一码事，它们最大的区别在于：头文件只存储变量、函数或者类等这些功能模块的声明部分，库文件才负责存储各模块具体的实现部分。读者可以这样理解：所有的库文件都提供有相应的头文件作为调用它的接口。也就是说，库文件是无法直接使用的，只能通过头文件间接调用。

事实上，库文件只是一个统称，代指的是一类压缩包，它们都包含有功能实用的目标文件。要知道，虽然库文件用于程序的链接阶段，但编译器提供有 2 种实现链接的方式，分别称为静态链接方式和动态链接方式，其中采用静态链接方式实现链接操作的库文件，称为静态链接库；采用动态链接方式实现链接操作的库文件，称为动态链接库。

### 静态链接库

静态链接是由链接器在链接时将库的内容加入到可执行程序中的做法。

静态链接库实现链接操作的方式很简单，即程序文件中哪里用到了库文件中的功能模块，GCC 编译器就会将该模板代码直接复制到程序文件的适当位置，最终生成可执行文件。

Windows下以.lib为后缀，Linux下以.a为后缀。

### 动态链接库

把链接这个过程推迟到了运行时再进行，在可执行文件装载时或运行时，由操作系统的装载程序加载库。

Windows下以.dll为后缀，Linux下以.so为后缀。

## Makefile

### all

makefile中本身是没有all指令的，只不过是一种约定，认为all可以同时做很多事儿，也就是能同时生成多个目标。一个Makefile中只有一个最终目标，就是第一个目标，一般就是all

### $@，$<，$^

$@表示目标文件，即当前规则中的目标。它可以用于指代当前规则中的目标文件名。在makefile中，可以通过$@来引用目标文件，以便在规则中对其进行操作或传递给其他命令。

$<表示第一个依赖文件，即当前规则中的第一个依赖文件。它可以用于指代当前规则中的第一个依赖文件名。在makefile中，可以通过$<来引用依赖文件，以便在规则中对其进行操作或传递给其他命令。

$^表示所有的依赖文件
